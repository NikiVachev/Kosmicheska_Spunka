<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ITPG Maze</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Space+Grotesk:wght@400;600&display=swap");

      :root {
        color-scheme: dark;
        --bg: #050505;
        --panel: rgba(9, 12, 15, 0.8);
        --panel-border: rgba(255, 255, 255, 0.1);
        --text: #f2f3f7;
        --muted: rgba(242, 243, 247, 0.65);
        --accent: #6fe0c9;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
      }

      body {
        font-family: "Space Grotesk", sans-serif;
        background: radial-gradient(circle at 20% 20%, #0b1115, #050505 55%);
        color: var(--text);
        overflow: hidden;
      }

      #gameRoot {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      .hud {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .crosshair {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 18px;
        height: 18px;
        transform: translate(-50%, -50%);
        border: 1px solid rgba(255, 255, 255, 0.35);
        border-radius: 50%;
        opacity: 0.65;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(
          135deg,
          rgba(5, 5, 5, 0.9),
          rgba(5, 5, 5, 0.7)
        );
        z-index: 4;
      }

      .overlay.is-hidden {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .overlay-card {
        width: min(420px, 90vw);
        padding: 22px 26px;
        border-radius: 16px;
        background: var(--panel);
        border: 1px solid var(--panel-border);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.6);
        display: grid;
        gap: 12px;
        text-align: center;
      }

      .overlay-card button {
        margin-top: 6px;
        padding: 10px 14px;
        border-radius: 12px;
        border: none;
        background: var(--accent);
        color: #071316;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
      }

      .pause-menu {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(
          135deg,
          rgba(5, 5, 5, 0.92),
          rgba(5, 5, 5, 0.75)
        );
        z-index: 5;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .pause-menu.is-visible {
        opacity: 1;
        pointer-events: auto;
      }

      .pause-card {
        width: min(360px, 85vw);
        padding: 20px 22px;
        border-radius: 16px;
        background: var(--panel);
        border: 1px solid var(--panel-border);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.6);
        display: grid;
        gap: 14px;
        text-align: center;
      }

      .pause-card h2 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .pause-card button {
        padding: 10px 14px;
        border-radius: 12px;
        border: none;
        background: var(--accent);
        color: #071316;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
      }

      .dialog {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding: 28px 24px 36px;
        background: linear-gradient(
          180deg,
          rgba(5, 5, 5, 0.1),
          rgba(5, 5, 5, 0.75) 70%
        );
        z-index: 6;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .dialog.is-visible {
        opacity: 1;
        pointer-events: auto;
      }

      .dialog-card {
        width: min(720px, 94vw);
        padding: 18px 20px;
        border-radius: 16px;
        background: var(--panel);
        border: 1px solid var(--panel-border);
        display: grid;
        gap: 12px;
      }

      .dialog-title {
        font-size: 12px;
        letter-spacing: 0.22em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .dialog-text {
        font-family: "IBM Plex Mono", monospace;
        font-size: 15px;
        line-height: 1.5;
        min-height: 3.2em;
      }

      .dialog-choices {
        display: grid;
        gap: 8px;
      }

      .dialog-choice {
        text-align: left;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(9, 12, 15, 0.8);
        color: var(--text);
        padding: 10px 12px;
        font-size: 14px;
        cursor: pointer;
      }

      .dialog-choice:hover {
        border-color: rgba(111, 224, 201, 0.6);
        background: rgba(111, 224, 201, 0.12);
      }

      .dialog-hint {
        font-size: 12px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      .touch-controls {
        position: absolute;
        left: 20px;
        right: 20px;
        bottom: 20px;
        display: none;
        justify-content: space-between;
        pointer-events: none;
        z-index: 3;
      }

      body.is-touch .touch-controls {
        display: flex;
      }

      .touch-pad,
      .touch-group {
        display: grid;
        gap: 8px;
        pointer-events: auto;
      }

      .touch-pad {
        grid-template-columns: repeat(3, 44px);
        grid-template-rows: repeat(3, 44px);
      }

      .touch-group {
        grid-template-columns: repeat(2, 52px);
        grid-template-rows: repeat(2, 52px);
      }

      .touch-btn {
        width: 52px;
        height: 52px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(9, 12, 15, 0.7);
        color: var(--text);
        font-family: "IBM Plex Mono", monospace;
        font-size: 14px;
        text-transform: uppercase;
      }

      .touch-btn.is-blank {
        opacity: 0;
        pointer-events: none;
      }

    </style>
  </head>
  <body>
    <div id="gameRoot">
      <div class="overlay" id="overlay">
        <div class="overlay-card">
          <button type="button" id="startBtn">Enter</button>
        </div>
      </div>

      <div class="hud">
        <div class="crosshair"></div>
      </div>

      <div class="pause-menu" id="pauseMenu" aria-hidden="true">
        <div class="pause-card">
          <h2>Paused</h2>
          <button type="button" id="resumeBtn">Resume</button>
        </div>
      </div>

      <div class="dialog" id="dialog" aria-hidden="true">
        <div class="dialog-card">
          <div class="dialog-title" id="dialogTitle">Exit</div>
          <div class="dialog-text" id="dialogText"></div>
          <div class="dialog-choices" id="dialogChoices"></div>
          <div class="dialog-hint" id="dialogHint">Click or press Space</div>
        </div>
      </div>

      <div class="touch-controls" id="touchControls">
        <div class="touch-pad">
          <button class="touch-btn is-blank" type="button"></button>
          <button class="touch-btn" type="button" data-move="forward">W</button>
          <button class="touch-btn is-blank" type="button"></button>
          <button class="touch-btn" type="button" data-move="left">A</button>
          <button class="touch-btn is-blank" type="button"></button>
          <button class="touch-btn" type="button" data-move="right">D</button>
          <button class="touch-btn is-blank" type="button"></button>
          <button class="touch-btn" type="button" data-move="back">S</button>
          <button class="touch-btn is-blank" type="button"></button>
        </div>
        <div class="touch-group">
          <button class="touch-btn" type="button" data-move="reset">
            Reset
          </button>
        </div>
      </div>
    </div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script>
      const overlay = document.getElementById("overlay");
      const startBtn = document.getElementById("startBtn");
      const pauseMenu = document.getElementById("pauseMenu");
      const resumeBtn = document.getElementById("resumeBtn");
      const dialog = document.getElementById("dialog");
      const dialogTitle = document.getElementById("dialogTitle");
      const dialogText = document.getElementById("dialogText");
      const dialogChoices = document.getElementById("dialogChoices");
      const dialogHint = document.getElementById("dialogHint");
      const touchControls = document.getElementById("touchControls");
      const isTouch =
        "ontouchstart" in window || navigator.maxTouchPoints > 0;
      document.body.classList.toggle("is-touch", isTouch);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x050505);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.getElementById("gameRoot").appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x050505, 8, 120);

      const camera = new THREE.PerspectiveCamera(
        68,
        window.innerWidth / window.innerHeight,
        0.1,
        220
      );

      const yawObject = new THREE.Object3D();
      const pitchObject = new THREE.Object3D();
      yawObject.add(pitchObject);
      pitchObject.add(camera);
      scene.add(yawObject);

      const maze = [
        "111111111101111111111",
        "100000000001000000001",
        "101111111101011111101",
        "101000001001010000101",
        "101011101111010111101",
        "101010001000010000101",
        "101010111011111110101",
        "100010100010000010001",
        "111110101110111010111",
        "100000100000000010001",
        "111110111010001110111",
        "100010000010001000001",
        "101110111110111011101",
        "101000100000001000101",
        "101011101111101110101",
        "101000001000001000101",
        "101111101011111010101",
        "100000001010000010001",
        "101111111010111111101",
        "100000000000100000001",
        "111111111101111111111",
      ];

      const START = { x: 10, y: 10 };
      const EXIT_A = { x: 10, y: 0 };
      const EXIT_B = { x: 10, y: 20 };
      const roomSize = 5;
      const roomHalf = Math.floor(roomSize / 2);

      const mazeRows = maze.length;
      const mazeCols = maze[0].length;
      const cellSize = 4;
      const wallHeight = 3.2;
      const mazeWidth = mazeCols * cellSize;
      const mazeDepth = mazeRows * cellSize;
      const halfMazeWidth = mazeWidth / 2;
      const halfMazeDepth = mazeDepth / 2;

      const cellToWorld = (x, y) => ({
        x: (x - mazeCols / 2 + 0.5) * cellSize,
        z: (y - mazeRows / 2 + 0.5) * cellSize,
      });

      const worldToCell = (x, z) => ({
        x: Math.floor((x + halfMazeWidth) / cellSize),
        y: Math.floor((z + halfMazeDepth) / cellSize),
      });

      const roomStartX = EXIT_A.x - roomHalf;
      const roomEndX = roomStartX + roomSize - 1;
      const topRoomStartY = -roomSize;
      const topRoomEndY = -1;
      const bottomRoomStartY = mazeRows;
      const bottomRoomEndY = mazeRows + roomSize - 1;
      const mapMinY = topRoomStartY;
      const mapMaxY = bottomRoomEndY;
      const mapRows = mapMaxY - mapMinY + 1;
      const mapCols = mazeCols;

      const wallCells = new Set();
      const wallCellList = [];
      const cellKey = (x, y) => `${x},${y}`;
      const addWallCell = (x, y) => {
        const key = cellKey(x, y);
        if (wallCells.has(key)) return;
        wallCells.add(key);
        wallCellList.push({ x, y });
      };
      const blockedCells = new Set();
      const addBlockedCell = (x, y) => {
        blockedCells.add(cellKey(x, y));
      };

      for (let y = 0; y < mazeRows; y += 1) {
        for (let x = 0; x < mazeCols; x += 1) {
          if (maze[y][x] === "1") {
            addWallCell(x, y);
          }
        }
      }

      const addRoomWalls = (isTop) => {
        const baseY = isTop ? topRoomEndY : bottomRoomStartY;
        for (let localY = 0; localY < roomSize; localY += 1) {
          for (let localX = 0; localX < roomSize; localX += 1) {
            const globalX = roomStartX + localX;
            const globalY = isTop ? baseY - localY : baseY + localY;
            const isBoundary =
              localX === 0 ||
              localX === roomSize - 1 ||
              localY === 0 ||
              localY === roomSize - 1;
            const isEntrance = localY === 0 && localX === roomHalf;
            if (isBoundary && !isEntrance) {
              addWallCell(globalX, globalY);
            }
          }
        }
      };

      addRoomWalls(true);
      addRoomWalls(false);
      const addRoomBlockers = (isTop) => {
        const baseY = isTop ? topRoomEndY : bottomRoomStartY;
        for (let localY = 1; localY < roomSize - 1; localY += 1) {
          for (let localX = 1; localX < roomSize - 1; localX += 1) {
            if (localX === roomHalf && localY === 1) continue;
            const globalX = roomStartX + localX;
            const globalY = isTop ? baseY - localY : baseY + localY;
            addBlockedCell(globalX, globalY);
          }
        }
      };
      addRoomBlockers(true);
      addRoomBlockers(false);

      const objectLocal = { x: roomHalf, y: roomHalf };
      const pianoLocal = { x: roomHalf, y: roomHalf + 1 };
      const toRoomGlobal = (local, isTop) => ({
        x: roomStartX + local.x,
        y: isTop ? topRoomEndY - local.y : bottomRoomStartY + local.y,
      });
      const topObjectCell = toRoomGlobal(objectLocal, true);
      const bottomObjectCell = toRoomGlobal(objectLocal, false);
      const topPianoCell = toRoomGlobal(pianoLocal, true);
      const bottomPianoCell = toRoomGlobal(pianoLocal, false);

      const isInBounds = (x, y) => {
        const inMaze = x >= 0 && y >= 0 && y < mazeRows && x < mazeCols;
        const inTopRoom =
          x >= roomStartX &&
          x <= roomEndX &&
          y >= topRoomStartY &&
          y <= topRoomEndY;
        const inBottomRoom =
          x >= roomStartX &&
          x <= roomEndX &&
          y >= bottomRoomStartY &&
          y <= bottomRoomEndY;
        return inMaze || inTopRoom || inBottomRoom;
      };

      const isWallCell = (x, y) => {
        if (!isInBounds(x, y)) return true;
        const key = cellKey(x, y);
        return wallCells.has(key) || blockedCells.has(key);
      };

      const findNearestOpenCell = (start) => {
        if (!isWallCell(start.x, start.y)) return { ...start };
        const visited = new Set();
        const queue = [{ x: start.x, y: start.y }];
        const key = (x, y) => `${x},${y}`;
        visited.add(key(start.x, start.y));
        const directions = [
          { x: 1, y: 0 },
          { x: -1, y: 0 },
          { x: 0, y: 1 },
          { x: 0, y: -1 },
        ];
        while (queue.length) {
          const current = queue.shift();
          for (const dir of directions) {
            const nx = current.x + dir.x;
            const ny = current.y + dir.y;
            const id = key(nx, ny);
            if (visited.has(id)) continue;
            visited.add(id);
            if (!isWallCell(nx, ny)) {
              return { x: nx, y: ny };
            }
            if (nx >= 0 && ny >= 0 && nx < mazeCols && ny < mazeRows) {
              queue.push({ x: nx, y: ny });
            }
          }
        }
        return { x: 1, y: 1 };
      };

      const startCell = findNearestOpenCell(START);
      const startWorld = cellToWorld(startCell.x, startCell.y);
      const exitWorldA = cellToWorld(EXIT_A.x, EXIT_A.y);
      const exitWorldB = cellToWorld(EXIT_B.x, EXIT_B.y);
      const exitFadeDistance = cellSize * 6;
      yawObject.position.set(startWorld.x, 1.6, startWorld.z);

      const floorMaterial = new THREE.MeshBasicMaterial({
        color: 0x050505,
        side: THREE.DoubleSide,
      });
      const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x050505 });
      wallMaterial.polygonOffset = true;
      wallMaterial.polygonOffsetFactor = 1;
      wallMaterial.polygonOffsetUnits = 1;
      const outlineCoreMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1,
        linewidth: 2,
        depthTest: true,
        depthWrite: false,
      });

      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(mazeWidth, mazeDepth),
        floorMaterial
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(0, 0, 0);
      scene.add(floor);

      const roomFloorGeometry = new THREE.PlaneGeometry(
        roomSize * cellSize,
        roomSize * cellSize
      );
      const topRoomCenter = cellToWorld(
        roomStartX + roomHalf,
        topRoomEndY - roomHalf
      );
      const bottomRoomCenter = cellToWorld(
        roomStartX + roomHalf,
        bottomRoomStartY + roomHalf
      );
      const topRoomFloor = new THREE.Mesh(roomFloorGeometry, floorMaterial);
      topRoomFloor.rotation.x = -Math.PI / 2;
      topRoomFloor.position.set(topRoomCenter.x, 0, topRoomCenter.z);
      scene.add(topRoomFloor);
      const bottomRoomFloor = new THREE.Mesh(roomFloorGeometry, floorMaterial);
      bottomRoomFloor.rotation.x = -Math.PI / 2;
      bottomRoomFloor.position.set(bottomRoomCenter.x, 0, bottomRoomCenter.z);
      scene.add(bottomRoomFloor);

      const wallGeometry = new THREE.BoxGeometry(
        cellSize,
        wallHeight,
        cellSize
      );
      const outlineOffset = 0.01;
      const outlineHalf = cellSize / 2;
      const outlineYBottom = 0.02;
      const outlineYTop = wallHeight + 0.02;
      const outlineCorePositions = [];
      const addOutlineLine = (positions, x1, y1, z1, x2, y2, z2) => {
        positions.push(x1, y1, z1, x2, y2, z2);
      };
      const addFaceRunZ = (positions, xStart, xEnd, y, normalZ, offset) => {
        const startWorld = cellToWorld(xStart, y);
        const endWorld = cellToWorld(xEnd, y);
        const left = startWorld.x - cellSize / 2 - offset;
        const right = endWorld.x + cellSize / 2 + offset;
        const z = startWorld.z + normalZ * (outlineHalf + offset);
        addOutlineLine(positions, left, outlineYBottom, z, left, outlineYTop, z);
        addOutlineLine(positions, right, outlineYBottom, z, right, outlineYTop, z);
        addOutlineLine(positions, left, outlineYTop, z, right, outlineYTop, z);
        addOutlineLine(
          positions,
          left,
          outlineYBottom,
          z,
          right,
          outlineYBottom,
          z
        );
      };
      const addFaceRunX = (positions, yStart, yEnd, x, normalX, offset) => {
        const startWorld = cellToWorld(x, yStart);
        const endWorld = cellToWorld(x, yEnd);
        const front = startWorld.z - cellSize / 2 - offset;
        const back = endWorld.z + cellSize / 2 + offset;
        const wx = startWorld.x + normalX * (outlineHalf + offset);
        addOutlineLine(positions, wx, outlineYBottom, front, wx, outlineYTop, front);
        addOutlineLine(positions, wx, outlineYBottom, back, wx, outlineYTop, back);
        addOutlineLine(positions, wx, outlineYTop, front, wx, outlineYTop, back);
        addOutlineLine(
          positions,
          wx,
          outlineYBottom,
          front,
          wx,
          outlineYBottom,
          back
        );
      };
      const wallCount = wallCellList.length;
      const walls = new THREE.InstancedMesh(wallGeometry, wallMaterial, wallCount);
      const wallMatrix = new THREE.Matrix4();
      let wallIndex = 0;
      wallCellList.forEach(({ x, y }) => {
        const world = cellToWorld(x, y);
        wallMatrix.makeTranslation(world.x, wallHeight / 2, world.z);
        walls.setMatrixAt(wallIndex, wallMatrix);
        wallIndex += 1;
      });
      walls.instanceMatrix.needsUpdate = true;

      const isWallInside = (x, y) => wallCells.has(cellKey(x, y));

      for (let y = topRoomStartY; y <= bottomRoomEndY; y += 1) {
        let runStart = null;
        for (let x = 0; x < mazeCols; x += 1) {
          const exposed = isWallInside(x, y) && !isWallInside(x, y + 1);
          if (exposed && runStart === null) runStart = x;
          if ((!exposed || x === mazeCols - 1) && runStart !== null) {
            const runEnd = exposed && x === mazeCols - 1 ? x : x - 1;
            addFaceRunZ(outlineCorePositions, runStart, runEnd, y, 1, outlineOffset);
            runStart = null;
          }
        }
      }

      for (let y = topRoomStartY; y <= bottomRoomEndY; y += 1) {
        let runStart = null;
        for (let x = 0; x < mazeCols; x += 1) {
          const exposed = isWallInside(x, y) && !isWallInside(x, y - 1);
          if (exposed && runStart === null) runStart = x;
          if ((!exposed || x === mazeCols - 1) && runStart !== null) {
            const runEnd = exposed && x === mazeCols - 1 ? x : x - 1;
            addFaceRunZ(outlineCorePositions, runStart, runEnd, y, -1, outlineOffset);
            runStart = null;
          }
        }
      }

      for (let x = 0; x < mazeCols; x += 1) {
        let runStart = null;
        for (let y = topRoomStartY; y <= bottomRoomEndY; y += 1) {
          const exposed = isWallInside(x, y) && !isWallInside(x + 1, y);
          if (exposed && runStart === null) runStart = y;
          if ((!exposed || y === bottomRoomEndY) && runStart !== null) {
            const runEnd = exposed && y === bottomRoomEndY ? y : y - 1;
            addFaceRunX(outlineCorePositions, runStart, runEnd, x, 1, outlineOffset);
            runStart = null;
          }
        }
      }

      for (let x = 0; x < mazeCols; x += 1) {
        let runStart = null;
        for (let y = topRoomStartY; y <= bottomRoomEndY; y += 1) {
          const exposed = isWallInside(x, y) && !isWallInside(x - 1, y);
          if (exposed && runStart === null) runStart = y;
          if ((!exposed || y === bottomRoomEndY) && runStart !== null) {
            const runEnd = exposed && y === bottomRoomEndY ? y : y - 1;
            addFaceRunX(outlineCorePositions, runStart, runEnd, x, -1, outlineOffset);
            runStart = null;
          }
        }
      }

      for (let y = topRoomStartY; y <= bottomRoomEndY; y += 1) {
        for (let x = 0; x < mazeCols; x += 1) {
          if (!isWallInside(x, y)) continue;
          const world = cellToWorld(x, y);
          const exposedPosX = !isWallInside(x + 1, y);
          const exposedNegX = !isWallInside(x - 1, y);
          const exposedPosZ = !isWallInside(x, y + 1);
          const exposedNegZ = !isWallInside(x, y - 1);
          const addCorner = (offsetX, offsetZ) => {
            addOutlineLine(
              outlineCorePositions,
              world.x + offsetX,
              outlineYBottom,
              world.z + offsetZ,
              world.x + offsetX,
              outlineYTop,
              world.z + offsetZ
            );
          };
          if (exposedPosX && exposedPosZ) {
            addCorner(outlineHalf + outlineOffset, outlineHalf + outlineOffset);
          }
          if (exposedPosX && exposedNegZ) {
            addCorner(outlineHalf + outlineOffset, -outlineHalf - outlineOffset);
          }
          if (exposedNegX && exposedPosZ) {
            addCorner(-outlineHalf - outlineOffset, outlineHalf + outlineOffset);
          }
          if (exposedNegX && exposedNegZ) {
            addCorner(-outlineHalf - outlineOffset, -outlineHalf - outlineOffset);
          }
        }
      }
      scene.add(walls);
      const addOutline = (positions, material) => {
        if (!positions.length) return;
        const outlineGeometry = new THREE.BufferGeometry();
        outlineGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        const outlineLines = new THREE.LineSegments(outlineGeometry, material);
        outlineLines.renderOrder = 2;
        scene.add(outlineLines);
      };
      addOutline(outlineCorePositions, outlineCoreMaterial);

      const wallTextPhrases = [
        "THE WALLS KEEP TIME.",
        "EVERY STEP HAS A TEMPO.",
        "SILENCE IS PART OF THE MAZE.",
        "YOU MISSED A BEAT BACK THERE.",
        "THIS TURN REPEATS.",
        "LISTEN BEFORE YOU MOVE.",
        "THE MAZE HUMS WHEN YOU'RE NOT LOOKING.",
        "SOME NOTES ARE MEANT TO BE SKIPPED.",
        "THE EXIT IS OUT OF RHYTHM.",
        "DID YOU MEAN TO COME THIS WAY?",
        "WHO DECIDED THIS TURN?",
        "WHAT DID YOU EXPECT TO FIND?",
        "ARE YOU FOLLOWING OR LEADING?",
        "WOULD YOU WALK DIFFERENTLY IF YOU KNEW?",
        "NOT YET.",
        "TOO SOON.",
        "AGAIN.",
        "ALMOST.",
        "LISTEN.",
        "WAIT.",
        "REMEMBER THIS.",
      ];

      const wrapWallText = (ctx, text, maxWidth) => {
        const words = text.split(" ");
        const lines = [];
        let line = "";
        words.forEach((word) => {
          const testLine = line ? `${line} ${word}` : word;
          if (ctx.measureText(testLine).width > maxWidth && line) {
            lines.push(line);
            line = word;
          } else {
            line = testLine;
          }
        });
        if (line) lines.push(line);
        return lines;
      };

      const fitWallText = (ctx, text, maxWidth, maxHeight) => {
        let fontSize = 32;
        while (fontSize >= 18) {
          ctx.font = `600 ${fontSize}px 'IBM Plex Mono', monospace`;
          const lines = wrapWallText(ctx, text, maxWidth);
          const lineHeight = fontSize * 1.2;
          const totalHeight = lines.length * lineHeight;
          const widest = lines.reduce(
            (max, line) => Math.max(max, ctx.measureText(line).width),
            0
          );
          if (widest <= maxWidth && totalHeight <= maxHeight) {
            return { lines, fontSize, lineHeight };
          }
          fontSize -= 2;
        }
        ctx.font = "600 18px 'IBM Plex Mono', monospace";
        return {
          lines: wrapWallText(ctx, text, maxWidth),
          fontSize: 18,
          lineHeight: 18 * 1.2,
        };
      };

      const createWallTextTexture = (text) => {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const padding = 28;
        const maxWidth = canvas.width - padding * 2;
        const maxHeight = canvas.height - padding * 2;
        const { lines, fontSize, lineHeight } = fitWallText(
          ctx,
          text,
          maxWidth,
          maxHeight
        );
        ctx.font = `600 ${fontSize}px 'IBM Plex Mono', monospace`;
        const startY =
          canvas.height / 2 - ((lines.length - 1) * lineHeight) / 2;
        ctx.strokeStyle = "rgba(0, 0, 0, 0.45)";
        ctx.lineWidth = 5;
        ctx.fillStyle = "rgba(245, 245, 245, 0.92)";
        lines.forEach((line, index) => {
          const y = startY + index * lineHeight;
          ctx.strokeText(line, canvas.width / 2, y);
          ctx.fillText(line, canvas.width / 2, y);
        });
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.minFilter = THREE.LinearFilter;
        texture.needsUpdate = true;
        return { texture, lines };
      };

      const wallTextPanels = [];
      const wallTextGroup = new THREE.Group();
      const wallFaces = [];
      wallCellList.forEach(({ x, y }) => {
        if (!isWallCell(x, y - 1)) wallFaces.push({ x, y, nx: 0, nz: -1 });
        if (!isWallCell(x, y + 1)) wallFaces.push({ x, y, nx: 0, nz: 1 });
        if (!isWallCell(x - 1, y)) wallFaces.push({ x, y, nx: -1, nz: 0 });
        if (!isWallCell(x + 1, y)) wallFaces.push({ x, y, nx: 1, nz: 0 });
      });

      for (let i = wallFaces.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [wallFaces[i], wallFaces[j]] = [wallFaces[j], wallFaces[i]];
      }

      const textOffset = 0.06;
      const maxPlaneWidth = cellSize * 0.85;
      const maxPlaneHeight = wallHeight * 0.75;
      const desiredWallTextCount = Math.min(
        wallFaces.length,
        wallTextPhrases.length * 4
      );
      for (let i = 0; i < desiredWallTextCount; i += 1) {
        const face = wallFaces[i % wallFaces.length];
        if (!face) continue;
        const phrase =
          wallTextPhrases[Math.floor(Math.random() * wallTextPhrases.length)];
        const { texture, lines } = createWallTextTexture(phrase);
        const planeWidth = maxPlaneWidth;
        const planeHeight = Math.min(
          maxPlaneHeight,
          cellSize * 0.3 + Math.max(lines.length - 1, 0) * cellSize * 0.15
        );
        const baseOpacity = 0.55 + Math.random() * 0.25;
        const plane = new THREE.Mesh(
          new THREE.PlaneGeometry(planeWidth, planeHeight),
          new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            depthWrite: false,
            opacity: baseOpacity,
          })
        );
        const world = cellToWorld(face.x, face.y);
        const heightMin = planeHeight / 2 + 0.25;
        const heightMax = wallHeight - planeHeight / 2 - 0.25;
        const textY =
          heightMin +
          Math.random() * Math.max(0.01, heightMax - heightMin);
        const jitterRange = Math.max(
          0,
          (cellSize - planeWidth) / 2 - cellSize * 0.08
        );
        const sideJitter = (Math.random() - 0.5) * jitterRange * 2;
        const offsetX = face.nz !== 0 ? sideJitter : 0;
        const offsetZ = face.nx !== 0 ? sideJitter : 0;
        plane.position.set(
          world.x + face.nx * (cellSize / 2 + textOffset) + offsetX,
          textY,
          world.z + face.nz * (cellSize / 2 + textOffset) + offsetZ
        );
        if (face.nz === -1) plane.rotation.y = Math.PI;
        if (face.nx === 1) plane.rotation.y = Math.PI / 2;
        if (face.nx === -1) plane.rotation.y = -Math.PI / 2;
        plane.rotation.y += (Math.random() - 0.5) * 0.06;
        plane.rotation.x = (Math.random() - 0.5) * 0.12;
        plane.rotation.z = (Math.random() - 0.5) * 0.22;
        const baseScale = 0.92 + Math.random() * 0.18;
        plane.scale.set(baseScale, baseScale, 1);
        wallTextGroup.add(plane);
        wallTextPanels.push({ mesh: plane, baseScale, baseOpacity });
      }
      scene.add(wallTextGroup);

      const objectMaterial = new THREE.MeshBasicMaterial({ color: 0x1b2127 });
      const objectHeight = 200;
      const objectGeometry = new THREE.CylinderGeometry(0.75, 0.95, objectHeight, 8);
      const placeObject = (cell) => {
        const world = cellToWorld(cell.x, cell.y);
        const objectMesh = new THREE.Mesh(objectGeometry, objectMaterial);
        objectMesh.position.set(world.x, objectHeight / 2, world.z);
        scene.add(objectMesh);
      };
      placeObject(topObjectCell);
      placeObject(bottomObjectCell);
      [
        { x: 2, y: 0 },
        { x: 18, y: 0 },
        { x: 2, y: 20 },
        { x: 18, y: 20 },
        { x: 2, y: 2 },
        { x: 15, y: 14 },
      ].forEach((cell) => {
        if (wallCells.has(cellKey(cell.x, cell.y))) {
          placeObject(cell);
        }
      });
      [
        { x: -3, y: 4 },
        { x: mazeCols + 3, y: 10 },
        { x: -2, y: topRoomStartY - 3 },
        { x: mazeCols + 2, y: bottomRoomEndY + 3 },
        { x: -6, y: -2 },
        { x: mazeCols + 6, y: 18 },
        { x: -4, y: bottomRoomEndY + 6 },
        { x: mazeCols + 4, y: topRoomStartY - 6 },
      ].forEach((cell) => {
        placeObject(cell);
      });

      const pianoMaterial = new THREE.MeshBasicMaterial({ color: 0x0d1116 });
      const pianoKeyMaterial = new THREE.MeshBasicMaterial({ color: 0xf2f2f2 });
      const createPiano = () => {
        const group = new THREE.Group();
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(2.6, 0.8, 1.2),
          pianoMaterial
        );
        base.position.y = 0.4;
        const lid = new THREE.Mesh(
          new THREE.BoxGeometry(2.6, 0.2, 1.2),
          pianoMaterial
        );
        lid.position.y = 0.9;
        lid.position.z = -0.05;
        const keys = new THREE.Mesh(
          new THREE.BoxGeometry(2.2, 0.15, 0.5),
          pianoKeyMaterial
        );
        keys.position.y = 0.82;
        keys.position.z = 0.35;
        group.add(base, lid, keys);
        return group;
      };
      const placePiano = (cell, facingForward) => {
        const world = cellToWorld(cell.x, cell.y);
        const piano = createPiano();
        piano.position.set(world.x, 0, world.z);
        piano.rotation.y = facingForward ? 0 : Math.PI;
        scene.add(piano);
      };
      placePiano(topPianoCell, true);
      placePiano(bottomPianoCell, false);

      const centerTotemTextureSrc = "reward.png";
      const createBeamGlowTexture = () => {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, 128, 128);
        const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 60);
        gradient.addColorStop(0, "rgba(200, 255, 255, 1)");
        gradient.addColorStop(0.35, "rgba(150, 230, 255, 0.7)");
        gradient.addColorStop(0.7, "rgba(120, 200, 255, 0.25)");
        gradient.addColorStop(1, "rgba(120, 200, 255, 0)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(64, 64, 60, 0, Math.PI * 2);
        ctx.fill();
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
      };
      const createCenterTotem = (position) => {
        const group = new THREE.Group();
        const totemMaterial = new THREE.MeshBasicMaterial({
          color: 0x263743,
          transparent: true,
          opacity: 0.85,
        });
        totemMaterial.fog = false;
        const totemHeight = 1.2;
        const totemGeometry = new THREE.CylinderGeometry(1.05, 1.05, totemHeight, 24);
        const totemMesh = new THREE.Mesh(totemGeometry, totemMaterial);
        totemMesh.position.y = totemHeight / 2;
        group.add(totemMesh);

        const beamHeight = 140;
        const beamMaterial = new THREE.MeshBasicMaterial({
          color: 0x9ff6ff,
          transparent: true,
          opacity: 0.4,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        beamMaterial.fog = false;
        const beamGeometry = new THREE.CylinderGeometry(0.6, 1.4, beamHeight, 24, 1, true);
        const beamMesh = new THREE.Mesh(beamGeometry, beamMaterial);
        beamMesh.position.y = totemHeight + beamHeight / 2;
        group.add(beamMesh);
        const beamCoreMaterial = new THREE.MeshBasicMaterial({
          color: 0xd6fbff,
          transparent: true,
          opacity: 0.78,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        beamCoreMaterial.fog = false;
        const beamCoreGeometry = new THREE.CylinderGeometry(
          0.25,
          0.7,
          beamHeight,
          16,
          1,
          true
        );
        const beamCore = new THREE.Mesh(beamCoreGeometry, beamCoreMaterial);
        beamCore.position.y = totemHeight + beamHeight / 2;
        group.add(beamCore);
        const glowTexture = createBeamGlowTexture();
        const glowMaterial = new THREE.SpriteMaterial({
          map: glowTexture,
          color: 0xbefbff,
          transparent: true,
          opacity: 0.95,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        glowMaterial.fog = false;
        const glowSprite = new THREE.Sprite(glowMaterial);
        glowSprite.scale.set(9, 9, 1);
        glowSprite.position.set(0, totemHeight + 0.4, 0);
        group.add(glowSprite);

        const particleCount = 180;
        const particlePositions = new Float32Array(particleCount * 3);
        const particleSpeeds = new Float32Array(particleCount);
        const particleRadius = 1.1;
        for (let i = 0; i < particleCount; i += 1) {
          const angle = Math.random() * Math.PI * 2;
          const radius = 0.15 + Math.random() * particleRadius;
          const y = Math.random() * beamHeight;
          const idx = i * 3;
          particlePositions[idx] = Math.cos(angle) * radius;
          particlePositions[idx + 1] = totemHeight + y;
          particlePositions[idx + 2] = Math.sin(angle) * radius;
          particleSpeeds[i] = 2 + Math.random() * 6;
        }
        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(particlePositions, 3)
        );
        const particleMaterial = new THREE.PointsMaterial({
          color: 0xe9ffff,
          size: 0.28,
          transparent: true,
          opacity: 0.78,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        particleMaterial.fog = false;
        const particlePoints = new THREE.Points(particleGeometry, particleMaterial);
        group.add(particlePoints);

        const decalBaseHeight = 2.2;
        const decalMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.85,
          side: THREE.DoubleSide,
        });
        decalMaterial.fog = false;
        decalMaterial.depthWrite = false;
        const decal = new THREE.Mesh(
          new THREE.PlaneGeometry(1, 1),
          decalMaterial
        );
        decal.scale.set(decalBaseHeight, decalBaseHeight, 1);
        if (centerTotemTextureSrc) {
          const loader = new THREE.TextureLoader();
          const rewardTextureCandidates = [
            centerTotemTextureSrc,
            "game/reward.png",
          ];
          const loadTotemTexture = (index) => {
            if (index >= rewardTextureCandidates.length) return;
            const src = rewardTextureCandidates[index];
            if (!src) {
              loadTotemTexture(index + 1);
              return;
            }
            loader.load(
              src,
              (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                decalMaterial.map = texture;
                decalMaterial.needsUpdate = true;
                const aspect =
                  texture.image && texture.image.height
                    ? texture.image.width / texture.image.height
                    : 1;
                decal.scale.set(decalBaseHeight * aspect, decalBaseHeight, 1);
              },
              undefined,
              () => loadTotemTexture(index + 1)
            );
          };
          loadTotemTexture(0);
        }
        decal.position.set(
          0,
          totemHeight + 0.45 + (decalBaseHeight * 0.5),
          0
        );
        group.add(decal);
        group.userData.decal = decal;
        group.userData.decalBaseOpacity = decalMaterial.opacity;
        group.userData.totemMesh = totemMesh;
        group.userData.totemBaseOpacity = totemMaterial.opacity;
        group.userData.beamMesh = beamMesh;
        group.userData.beamCore = beamCore;
        group.userData.beamGlow = glowSprite;
        group.userData.beamBaseOpacity = beamMaterial.opacity;
        group.userData.coreBaseOpacity = beamCoreMaterial.opacity;
        group.userData.glowBaseOpacity = glowMaterial.opacity;
        group.userData.glowBaseScale = glowSprite.scale.x;
        group.userData.particles = particlePoints;
        group.userData.particleSpeeds = particleSpeeds;
        group.userData.particleRadius = particleRadius;
        group.userData.particleBaseSize = particleMaterial.size;
        group.userData.particleBaseOpacity = particleMaterial.opacity;
        group.userData.beamHeight = beamHeight;
        group.userData.totemHeight = totemHeight;

        group.position.set(position.x, 0, position.z);
        return group;
      };

      const centerTotem = createCenterTotem(startWorld);
      centerTotem.visible = false;
      scene.add(centerTotem);
      const centerTotemFadeStart = cellSize * 10;
      const centerTotemFadeEnd = cellSize * 3;

      const starCount = 2200;
      const createStarTexture = (kind) => {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, 64, 64);
        if (kind === "square") {
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          ctx.fillRect(20, 20, 24, 24);
          ctx.shadowColor = "rgba(255,255,255,0.75)";
          ctx.shadowBlur = 10;
          ctx.fillRect(22, 22, 20, 20);
        } else if (kind === "spark") {
          ctx.strokeStyle = "rgba(255,255,255,0.9)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(10, 32);
          ctx.lineTo(54, 32);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(32, 10);
          ctx.lineTo(32, 54);
          ctx.stroke();
          ctx.strokeStyle = "rgba(255,255,255,0.6)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(16, 16);
          ctx.lineTo(48, 48);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(48, 16);
          ctx.lineTo(16, 48);
          ctx.stroke();
        } else {
          const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 28);
          gradient.addColorStop(0, "rgba(255,255,255,1)");
          gradient.addColorStop(0.35, "rgba(255,255,255,0.9)");
          gradient.addColorStop(0.7, "rgba(255,255,255,0.25)");
          gradient.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(32, 32, 28, 0, Math.PI * 2);
          ctx.fill();
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        return texture;
      };
      const starTextures = {
        circle: createStarTexture("circle"),
        square: createStarTexture("square"),
        spark: createStarTexture("spark"),
      };
      const totalDepth = mazeDepth + roomSize * cellSize * 2;
      const mazeRadius = Math.max(mazeWidth, totalDepth) * 0.55;
      const starRadius = Math.max(mazeRadius, 45);
      const starYOffset = wallHeight * 2.8;
      const fillStarPositions = (positions) => {
        for (let i = 0; i < positions.length / 3; i += 1) {
          const theta = Math.random() * Math.PI * 2;
          const cosPhi = Math.random();
          const sinPhi = Math.sqrt(1 - cosPhi * cosPhi);
          const radius = starRadius * (0.75 + Math.random() * 0.4);
          positions[i * 3] = Math.cos(theta) * sinPhi * radius;
          positions[i * 3 + 1] = cosPhi * radius;
          positions[i * 3 + 2] = Math.sin(theta) * sinPhi * radius;
        }
      };
      const starSizeRange = 0.7;
      const starDesigns = [
        { kind: "circle", count: Math.floor(starCount * 0.55), baseSize: 0.42 },
        { kind: "square", count: Math.floor(starCount * 0.25), baseSize: 0.36 },
        {
          kind: "spark",
          count: starCount - Math.floor(starCount * 0.55) - Math.floor(starCount * 0.25),
          baseSize: 0.5,
        },
      ];
      const starMaterials = [];
      const starField = new THREE.Group();
      starDesigns.forEach((design) => {
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(design.count * 3);
        fillStarPositions(starPositions);
        starGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(starPositions, 3)
        );
        const starMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: design.baseSize,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.75,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          alphaTest: 0.2,
          map: starTextures[design.kind],
        });
        starMaterial.fog = false;
        starMaterials.push({ material: starMaterial, baseSize: design.baseSize });
        const stars = new THREE.Points(starGeometry, starMaterial);
        starField.add(stars);
      });
      scene.add(starField);

      const glyphPalette = {
        low: ["ð„¢", "ð„¡", "â™­", "â™®"],
        mid: ["â™ª", "â™«", "â™©", "â™¬", "ð„ž"],
        high: ["ð„ž", "â™¯", "â™®", "ð„ª"],
        beat: ["â™ª", "â™©", "â™¬", "ð„†", "ð„‡"],
      };

      const glyphTextureCache = new Map();
      const makeGlyphTexture = (text) => {
        if (glyphTextureCache.has(text)) {
          return glyphTextureCache.get(text);
        }
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const fontSize = 54;
        const padding = 28;
        const fontStack =
          "'Segoe UI Symbol', 'Noto Music', 'Noto Sans Symbols', 'Space Grotesk', sans-serif";
        ctx.font = `600 ${fontSize}px ${fontStack}`;
        const metrics = ctx.measureText(text);
        const width = Math.ceil(metrics.width) + padding * 2;
        const height = fontSize + padding * 2;
        const scale = 2;
        canvas.width = width * scale;
        canvas.height = height * scale;
        ctx.scale(scale, scale);
        ctx.font = `600 ${fontSize}px ${fontStack}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 255, 255, 0.92)";
        ctx.shadowColor = "rgba(120, 220, 210, 0.9)";
        ctx.shadowBlur = 16;
        ctx.fillText(text, width / 2, height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        glyphTextureCache.set(text, texture);
        return texture;
      };

      const glyphGroup = new THREE.Group();
      scene.add(glyphGroup);
      const glyphs = [];
      const spawnGlyphPosition = (glyph) => {
        const useFarShell = Math.random() > 0.6;
        const minRadius = useFarShell ? starRadius * 1.05 : starRadius * 0.35;
        const maxRadius = useFarShell ? starRadius * 1.8 : starRadius * 0.85;
        const radius = minRadius + Math.random() * (maxRadius - minRadius);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * (Math.PI * 0.5);
        const sinPhi = Math.sin(phi);
        glyph.sprite.position.set(
          Math.cos(theta) * sinPhi * radius,
          Math.cos(phi) * radius,
          Math.sin(theta) * sinPhi * radius
        );
      };

      const addGlyph = (band) => {
        const choices = glyphPalette[band] || glyphPalette.mid;
        const text = choices[Math.floor(Math.random() * choices.length)];
        const texture = makeGlyphTexture(text);
        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        const sprite = new THREE.Sprite(material);
        const baseScale = 0.7 + Math.random() * 1.2;
        sprite.scale.set(baseScale * 2.2, baseScale * 1.2, 1);
        glyphGroup.add(sprite);
        const glyph = {
          sprite,
          band,
          baseScale,
          driftX: (Math.random() * 0.6 + 0.1) * (Math.random() < 0.5 ? -1 : 1),
          driftY: (Math.random() * 0.4 + 0.05) * (Math.random() < 0.5 ? -1 : 1),
          driftZ: (Math.random() * 0.35 + 0.1) * (Math.random() < 0.5 ? -1 : 1),
          bob: Math.random() * Math.PI * 2,
          speed: 0.35 + Math.random() * 0.5,
          flicker: Math.random() * 0.6 + 0.4,
        };
        spawnGlyphPosition(glyph);
        glyphs.push(glyph);
      };

      ["low", "mid", "mid", "high", "high", "beat"].forEach((band) => {
        for (let i = 0; i < 10; i += 1) {
          addGlyph(band);
        }
      });

      const musicTrack = new Audio();
      const exitTrack = new Audio();
      const exitTrackPrimary = "trak1.WAV";
      const exitTrackSecondary = "trak2.WAV";
      musicTrack.src = encodeURI("deltarune  'glaceir' remix.mp3");
      exitTrack.src = exitTrackPrimary;
      musicTrack.loop = true;
      exitTrack.loop = true;
      musicTrack.preload = "auto";
      exitTrack.preload = "auto";
      const baseMusicVolume = 0.7;
      const baseExitVolume = 0.9;
      musicTrack.volume = baseMusicVolume;
      exitTrack.volume = 0;
      let audioContext = null;
      let analyser = null;
      let audioData = null;
      let exitAnalyser = null;
      let exitAudioData = null;
      let audioStarted = false;
      let musicGain = null;
      let exitGain = null;
      let lastExitCheck = 0;
      let currentMusicVolume = baseMusicVolume;
      let currentExitVolume = 0;
      let starIntensity = 0;
      let beatPulse = 0;
      let lowMemory = 0;

      const initAudio = () => {
        if (audioContext) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return;
        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        exitAnalyser = audioContext.createAnalyser();
        analyser.fftSize = 512;
        exitAnalyser.fftSize = 512;
        musicGain = audioContext.createGain();
        exitGain = audioContext.createGain();
        const source = audioContext.createMediaElementSource(musicTrack);
        const exitSource = audioContext.createMediaElementSource(exitTrack);
        source.connect(analyser);
        analyser.connect(musicGain);
        musicGain.connect(audioContext.destination);
        exitSource.connect(exitAnalyser);
        exitAnalyser.connect(exitGain);
        exitGain.connect(audioContext.destination);
        musicTrack.volume = 1;
        exitTrack.volume = 1;
        musicGain.gain.value = baseMusicVolume;
        exitGain.gain.value = 0;
        audioData = new Uint8Array(analyser.frequencyBinCount);
        exitAudioData = new Uint8Array(exitAnalyser.frequencyBinCount);
      };

      const clampVolume = (value) => Math.min(Math.max(value, 0), 1);

      const setMusicVolume = (value) => {
        const volume = clampVolume(value);
        if (musicGain) {
          musicGain.gain.value = volume;
        } else {
          musicTrack.volume = volume;
        }
        currentMusicVolume = volume;
      };

      const setExitVolume = (value) => {
        const volume = clampVolume(value);
        if (exitGain) {
          exitGain.gain.value = volume;
        } else {
          exitTrack.volume = volume;
        }
        currentExitVolume = volume;
      };

      const ensureExitTrackPlaying = () => {
        if (!exitTrack.paused || isPaused) return;
        const attempt = exitTrack.play();
        if (attempt && attempt.catch) {
          attempt.catch(() => {});
        }
      };

      const switchExitTrack = (src) => {
        if (!src) return;
        if (exitTrack.src && exitTrack.src.endsWith(src)) return;
        exitTrack.src = src;
        exitTrack.loop = true;
        exitTrack.load();
        exitTrack.currentTime = 0;
        setExitVolume(0);
        if (audioStarted && !isPaused) {
          const attempt = exitTrack.play();
          if (attempt && attempt.catch) {
            attempt.catch(() => {});
          }
        }
      };

      const startMusic = () => {
        if (audioStarted) return;
        audioStarted = true;
        initAudio();
        if (audioContext && audioContext.state === "suspended") {
          audioContext.resume();
        }
        exitTrack.currentTime = 0;
        setMusicVolume(baseMusicVolume);
        setExitVolume(0);
        const mainPlay = musicTrack.play();
        if (mainPlay && mainPlay.catch) {
          mainPlay.catch(() => {
            audioStarted = false;
          });
        }
        const exitPlay = exitTrack.play();
        if (exitPlay && exitPlay.catch) {
          exitPlay.catch(() => {});
        }
      };

      const getBandAverage = (data, from, to) => {
        const end = Math.min(data.length - 1, to);
        if (end <= from) return 0;
        let sum = 0;
        for (let i = from; i <= end; i += 1) {
          sum += data[i];
        }
        return sum / (end - from + 1) / 255;
      };

      const getAudioBands = (delta) => {
        const mainActive = Boolean(analyser && audioData && !musicTrack.paused);
        const exitActive = Boolean(
          exitAnalyser && exitAudioData && !exitTrack.paused
        );
        if (!mainActive && !exitActive) {
          return { low: 0, mid: 0, high: 0, overall: 0, beat: 0 };
        }
        let mainBands = { low: 0, mid: 0, high: 0 };
        let exitBands = { low: 0, mid: 0, high: 0 };
        if (mainActive) {
          analyser.getByteFrequencyData(audioData);
          mainBands = {
            low: getBandAverage(audioData, 0, 14),
            mid: getBandAverage(audioData, 15, 60),
            high: getBandAverage(audioData, 61, 140),
          };
        }
        if (exitActive) {
          exitAnalyser.getByteFrequencyData(exitAudioData);
          exitBands = {
            low: getBandAverage(exitAudioData, 0, 14),
            mid: getBandAverage(exitAudioData, 15, 60),
            high: getBandAverage(exitAudioData, 61, 140),
          };
        }
        const totalVol = currentMusicVolume + currentExitVolume;
        let musicWeight = 0;
        let exitWeight = 0;
        if (totalVol > 0.001) {
          musicWeight = currentMusicVolume / totalVol;
          exitWeight = currentExitVolume / totalVol;
        } else {
          const activeCount = (mainActive ? 1 : 0) + (exitActive ? 1 : 0);
          musicWeight = mainActive ? 1 / activeCount : 0;
          exitWeight = exitActive ? 1 / activeCount : 0;
        }
        const low =
          mainBands.low * musicWeight + exitBands.low * exitWeight;
        const mid =
          mainBands.mid * musicWeight + exitBands.mid * exitWeight;
        const high =
          mainBands.high * musicWeight + exitBands.high * exitWeight;
        const overall = (low + mid + high) / 3;
        const rise = low - lowMemory;
        lowMemory = lowMemory * 0.85 + low * 0.15;
        if (rise > 0.08 && low > 0.22) {
          beatPulse = 1;
        } else {
          beatPulse = Math.max(0, beatPulse - delta * 1.6);
        }
        return { low, mid, high, overall, beat: beatPulse };
      };

      const keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
      };
      const touchKeys = { ...keys };
      let pointerLocked = false;
      let hadPointerLock = false;
      let yaw = 0;
      let pitch = 0;
      let targetYaw = 0;
      let targetPitch = 0;
      let isPaused = false;
      let gameStarted = false;
      let ignoreEscapeUntil = 0;
      let lastPauseToggle = 0;
      let skipMouseMoves = 0;
      let isDialogOpen = false;
      let dialogQueue = [];
      let dialogLines = [];
      let dialogLineIndex = 0;
      let dialogChoiceActive = false;
      let dialogOnClose = null;
      const exitOrder = {
        firstExit: "",
        secondExit: "",
        firstDone: false,
        secondDone: false,
      };
      const exitDone = { top: false, bottom: false };
      const BELIEF_KEY = "itpg-belief-flag";
      let beliefFlag = "";
      try {
        beliefFlag = localStorage.getItem(BELIEF_KEY) || "";
      } catch (error) {}

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const applyLookDelta = (dx, dy, scale) => {
        if (!Number.isFinite(dx) || !Number.isFinite(dy)) return;
        const safeDx = clamp(dx, -240, 240);
        const safeDy = clamp(dy, -240, 240);
        targetYaw -= safeDx * scale;
        targetPitch -= safeDy * scale;
        targetPitch = clamp(targetPitch, -1.2, 1.2);
      };
      let dragLook = false;
      let dragPointerId = null;
      let lastLookX = 0;
      let lastLookY = 0;
      const onMouseMove = (event) => {
        if (isTouch) return;
        if (isPaused || isDialogOpen) return;
        if (!pointerLocked) return;
        if (skipMouseMoves > 0) {
          skipMouseMoves -= 1;
          return;
        }
        const scale = 0.0026;
        applyLookDelta(event.movementX, event.movementY, scale);
      };
      const onPointerMove = (event) => {
        if (isTouch) return;
        if (isPaused || isDialogOpen) return;
        const scale = 0.0026;
        if (pointerLocked) return;
        if (!dragLook) return;
        const dx = event.clientX - lastLookX;
        const dy = event.clientY - lastLookY;
        lastLookX = event.clientX;
        lastLookY = event.clientY;
        applyLookDelta(dx, dy, scale);
      };

      const onPointerMoveTouch = (event) => {
        if (!isTouch) return;
        if (isPaused || isDialogOpen) return;
        const touch = event.touches[0];
        if (!touch) return;
        if (typeof onPointerMoveTouch.lastX === "number") {
          const dx = touch.clientX - onPointerMoveTouch.lastX;
          const dy = touch.clientY - onPointerMoveTouch.lastY;
          applyLookDelta(dx, dy, 0.004);
        }
        onPointerMoveTouch.lastX = touch.clientX;
        onPointerMoveTouch.lastY = touch.clientY;
      };

      const resetTouchLook = () => {
        onPointerMoveTouch.lastX = null;
        onPointerMoveTouch.lastY = null;
      };

      const playerRadius = 0.6;
      const collidesAt = (x, z) => {
        const minX = x - playerRadius;
        const maxX = x + playerRadius;
        const minZ = z - playerRadius;
        const maxZ = z + playerRadius;
        const minCell = worldToCell(minX, minZ);
        const maxCell = worldToCell(maxX, maxZ);
        for (let cx = minCell.x; cx <= maxCell.x; cx += 1) {
          for (let cy = minCell.y; cy <= maxCell.y; cy += 1) {
            if (isWallCell(cx, cy)) {
              return true;
            }
          }
        }
        return false;
      };

      const moveWithCollisions = (velocity) => {
        if (!velocity) return;
        const nextX = yawObject.position.x + velocity.x;
        const nextZ = yawObject.position.z + velocity.z;
        if (!collidesAt(nextX, yawObject.position.z)) {
          yawObject.position.x = nextX;
        }
        if (!collidesAt(yawObject.position.x, nextZ)) {
          yawObject.position.z = nextZ;
        }
        yawObject.position.y = 1.6;
      };

      const updateMovement = (delta) => {
        if (isPaused || isDialogOpen) return;
        const forward =
          keys.forward || touchKeys.forward || keys.backward || touchKeys.backward;
        const strafe = keys.left || touchKeys.left || keys.right || touchKeys.right;
        if (!forward && !strafe) return;

        const moveSpeed = 4.2;
        const dir = new THREE.Vector3(
          (keys.right || touchKeys.right ? 1 : 0) -
            (keys.left || touchKeys.left ? 1 : 0),
          0,
          (keys.forward || touchKeys.forward ? 1 : 0) -
            (keys.backward || touchKeys.backward ? 1 : 0)
        );

        if (dir.lengthSq() > 0) {
          dir.normalize();
          const forwardVec = new THREE.Vector3();
          yawObject.getWorldDirection(forwardVec);
          forwardVec.y = 0;
          forwardVec.normalize();
          forwardVec.multiplyScalar(-1);
          const rightVec = new THREE.Vector3()
            .crossVectors(forwardVec, new THREE.Vector3(0, 1, 0))
            .normalize();
          const velocity = new THREE.Vector3()
            .addScaledVector(forwardVec, dir.z)
            .addScaledVector(rightVec, dir.x)
            .multiplyScalar(moveSpeed * delta);
          moveWithCollisions(velocity);
        }
      };

      const resetPlayer = () => {
        yawObject.position.set(startWorld.x, 1.6, startWorld.z);
        yaw = 0;
        pitch = 0;
        targetYaw = 0;
        targetPitch = 0;
      };

      const resetKeys = () => {
        Object.keys(keys).forEach((key) => {
          keys[key] = false;
        });
        Object.keys(touchKeys).forEach((key) => {
          touchKeys[key] = false;
        });
      };

      const setBeliefFlag = (value) => {
        beliefFlag = value;
        try {
          localStorage.setItem(BELIEF_KEY, value);
        } catch (error) {}
      };

      const exitOneIntro = [
        "YES",
        "NO",
        "AH.",
        "YOU'RE HERE.",
        "OR MAYBE YOU WERE HERE BEFORE.",
        "IT'S HARD TO TELL WITH MUSIC.",
        "DO YOU HEAR THAT?",
        "NO, NOT THAT.",
        "THE OTHER THING.",
        "WELL, NEVER MIND.",
        "MUSIC DOES THAT SOMETIMES.",
        "IT PRETENDS TO BE SILENT.",
        "YOU ARRIVED HERE FIRST.",
        "OR SECOND.",
        "OR NOT AT ALL.",
        "IT DOESN'T MATTER.",
        "THE MELODY FOUND YOU ANYWAY.",
        "PEOPLE THINK MUSIC IS MADE OF NOTES.",
        "THEY ARE WRONG.",
        "IT IS MADE OF DECISIONS",
        "THAT ALREADY HAPPENED.",
        "EVERY NOTE IS A FUTURE",
        "THAT HAS FINISHED PRACTICING.",
        "I LISTEN AHEAD.",
        "SOMETIMES I LISTEN TOO FAR",
        "AND HEAR THINGS THAT NEVER HAPPEN.",
        "THOSE ARE MY FAVORITE SONGS.",
        "NOW, BEFORE I FORGET WHY YOU'RE HERE...",
        "TELL ME.",
        "CAN THE FUTURE BE CHANGED.",
      ];

      const exitOneChoices = [
        {
          label: "The future is already written. I'm only discovering it.",
          belief: "written",
          response: [
            "YES.",
            "THEN YOU HEAR IT TOO.",
            "THE SONG DOES NOT WAIT FOR PERMISSION.",
            "IT PLAYS,",
            "AND YOU FOLLOW.",
            "I WILL REMEMBER",
            "THAT YOU TRUSTED THE MELODY.",
          ],
        },
        {
          label: "The future can still change, even if it has a melody.",
          belief: "variation",
          response: [
            "INTERESTING.",
            "YOU BELIEVE IN VARIATIONS.",
            "A SONG THAT BENDS,",
            "BUT NEVER BREAKS.",
            "I WILL REMEMBER",
            "THAT YOU LISTEN FOR CHANGES.",
          ],
        },
        {
          label: "Music doesn't predict the future. People do.",
          belief: "human",
          response: [
            "HM.",
            "THEN YOU THINK THE MUSIC IS LYING.",
            "OR PERHAPS",
            "IT IS WAITING FOR YOU TO SPEAK FIRST.",
            "I WILL REMEMBER",
            "THAT YOU DO NOT TRUST THE SOUND.",
          ],
        },
      ];

      const exitOneOutro = [
        "GOOD.",
        "OR BAD.",
        "I CAN NEVER REMEMBER",
        "WHICH IS WHICH.",
        "THE SONG CONTINUES WITHOUT ME.",
        "IT ALWAYS DOES.",
        "WHEN YOU HEAR IT AGAIN,",
        "IT WILL SOUND DIFFERENT.",
        "NOT BECAUSE IT CHANGED.",
        "BUT BECAUSE YOU",
        "ARE NOW LISTENING WRONG.",
        "...",
        "THAT WAS A JOKE.",
        "I THINK.",
      ];

      const exitTwoIntro = [
        "YES",
        "NO",
        "YOU CAME BACK.",
        "OR YOU CAME FORWARD.",
        "I CAN NEVER TELL WHICH DIRECTION TIME IS FACING.",
        "I KNOW WHAT YOU SAID BEFORE.",
        "DON'T ASK ME HOW.",
        "MUSIC TALKS WHEN PEOPLE STOP.",
        "SOMETIMES IT LIES.",
        "SOMETIMES I LIE FOR IT.",
        "THAT'S PART OF THE JOB.",
        "YOU REMEMBER WHAT YOU CHOSE, RIGHT?",
        "...",
        "DON'T ANSWER THAT.",
        "IT RUINS THE SURPRISE.",
      ];

      const exitTwoMain = [
        "MUSIC IS NOT A MAP.",
        "IT IS A QUESTION",
        "THAT NEVER STOPS ASKING ITSELF.",
        "I HAVE HEARD A THOUSAND FUTURES.",
        "MOST OF THEM",
        "FORGOT TO START.",
        "SOME OF THEM",
        "ENDED TOO LOUD.",
        "DO YOU KNOW WHAT HAPPENS",
        "WHEN NO ONE PLAYS?",
        "NEITHER DO I.",
        "THAT'S WHY I'M STILL HERE.",
        "NOW.",
        "BEFORE I DISAPPEAR",
        "OR REPEAT MYSELF",
        "OR BECOME PART OF THE BACKGROUND MUSIC...",
        "ANSWER ME ONE LAST TIME.",
        "WILL YOU PLAY THE MELODY"
      ];

      const exitTwoChoices = [
        {
          label: "I will play, even if I don't know the ending.",
          response: [
            "THEN THE FUTURE WILL BE LOUD.",
            "MISTAKES WILL BE HEARD.",
            "BUT THEY WILL BE YOURS.",
            "I WILL REMEMBER",
            "THAT YOU CHOSE TO BEGIN.",
          ],
        },
        {
          label: "I will wait. The future shouldn't be rushed.",
          response: [
            "SILENCE, THEN.",
            "A DANGEROUS CHOICE.",
            "THE FUTURE HATES EMPTY MEASURES.",
            "I WILL REMEMBER",
            "THAT YOU WAITED.",
          ],
        },
        {
          label: "I refuse to play your song.",
          response: [
            "...",
            "THAT IS ALSO A SONG.",
            "A SHORT ONE.",
            "I WILL REMEMBER",
            "THAT YOU WALKED AWAY.",
          ],
        },
      ];

      const exitTwoOutro = [
        "AH.",
        "THAT'S INTERESTING.",
        "OR TERRIBLE.",
        "I'LL DECIDE LATER.",
        "YOU HAVE GIVEN THE MUSIC",
        "SOMETHING IT DID NOT HAVE BEFORE.",
        "I CAN'T TELL YOU WHAT IT IS.",
        "IF I COULD,",
        "IT WOULDN'T WORK.",
        "WHEN WE MEET AGAIN,",
        "IT WON'T ASK YOU QUESTIONS.",
        "IT WILL HUM.",
        "AND IF YOU RECOGNIZE THE TUNE...",
        "WELL.",
        "THAT MEANS IT REMEMBERED YOU TOO.",
      ];

      const getExitTwoMemoryLines = () => {
        if (beliefFlag === "written") {
          return [
            "YOU TRUSTED THE MELODY.",
            "SO LET US SEE",
            "IF YOU CAN CHANGE THE TEMPO.",
            "THE MELODY IS STILL WAITING.",
          ];
        }
        if (beliefFlag === "variation") {
          return [
            "YOU LISTEN FOR CHANGES.",
            "THIS PLACE IS FULL OF SILENCE.",
            "BE CAREFUL WHAT YOU HEAR.",
            "THE MELODY IS STILL WAITING.",
          ];
        }
        if (beliefFlag === "human") {
          return [
            "YOU DO NOT TRUST THE SOUND.",
            "YET YOU CAME BACK",
            "TO LISTEN AGAIN.",
            "THE MELODY IS STILL WAITING.",
          ];
        }
        return [
          "YOU HAVE NOT ANSWERED BEFORE.",
          "THE MELODY IS STILL WAITING.",
        ];
      };

      const buildExitOneSequence = () => [
        { type: "lines", lines: exitOneIntro },
        { type: "choice", options: exitOneChoices },
        { type: "lines", lines: exitOneOutro },
      ];

      const buildExitTwoSequence = () => [
        { type: "lines", lines: exitTwoIntro },
        { type: "lines", lines: getExitTwoMemoryLines() },
        { type: "lines", lines: exitTwoMain },
        { type: "choice", options: exitTwoChoices },
        { type: "lines", lines: exitTwoOutro },
      ];

      const setDialogVisible = (value) => {
        if (!dialog) return;
        dialog.classList.toggle("is-visible", value);
        dialog.setAttribute("aria-hidden", String(!value));
      };

      const setDialogLine = (text) => {
        if (!dialogText) return;
        dialogText.textContent = text || "";
      };

      const showDialogChoices = (options) => {
        if (!dialogChoices) return;
        dialogChoiceActive = true;
        dialogChoices.innerHTML = "";
        if (dialogHint) dialogHint.textContent = "Select a choice";
        options.forEach((option) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "dialog-choice";
          button.textContent = option.label;
          button.addEventListener("click", () => {
            dialogChoiceActive = false;
            if (option.belief) {
              setBeliefFlag(option.belief);
            }
            if (option.response && option.response.length) {
              dialogQueue.unshift({ type: "lines", lines: option.response });
            }
            showNextDialogStep();
          });
          dialogChoices.appendChild(button);
        });
      };

      const showNextDialogStep = () => {
        if (!dialogQueue.length) {
          closeDialog();
          return;
        }
        const step = dialogQueue.shift();
        if (step.type === "lines") {
          dialogLines = step.lines || [];
          dialogLineIndex = 0;
          dialogChoiceActive = false;
          if (dialogChoices) dialogChoices.innerHTML = "";
          if (dialogHint) dialogHint.textContent = "Click or press Space";
          setDialogLine(dialogLines[dialogLineIndex] || "");
          return;
        }
        if (step.type === "choice") {
          showDialogChoices(step.options || []);
        }
      };

      const openDialogSequence = (sequence, onClose) => {
        if (!dialog) return;
        isDialogOpen = true;
        dialogQueue = sequence.slice();
        dialogLines = [];
        dialogLineIndex = 0;
        dialogChoiceActive = false;
        dialogOnClose = onClose || null;
        if (dialogTitle) dialogTitle.textContent = "MAN BEHIND THE MUSIC";
        resetKeys();
        setDialogLine("");
        setDialogVisible(true);
        if (document.exitPointerLock) {
          document.exitPointerLock();
        }
        showNextDialogStep();
      };

      const closeDialog = () => {
        isDialogOpen = false;
        dialogQueue = [];
        dialogLines = [];
        dialogLineIndex = 0;
        dialogChoiceActive = false;
        if (typeof dialogOnClose === "function") {
          dialogOnClose();
        }
        dialogOnClose = null;
        if (dialogChoices) dialogChoices.innerHTML = "";
        setDialogVisible(false);
        if (!isTouch && gameStarted && !isPaused && renderer?.domElement) {
          renderer.domElement.requestPointerLock?.();
        }
      };

      const advanceDialog = () => {
        if (!isDialogOpen || dialogChoiceActive) return;
        if (!dialogLines.length) {
          showNextDialogStep();
          return;
        }
        if (dialogLineIndex < dialogLines.length - 1) {
          dialogLineIndex += 1;
          setDialogLine(dialogLines[dialogLineIndex]);
        } else {
          showNextDialogStep();
        }
      };

      const setPaused = (value) => {
        if (!gameStarted) return;
        isPaused = value;
        lastPauseToggle = performance.now();
        if (musicTrack) {
          musicTrack.muted = isPaused;
        }
        if (exitTrack) {
          exitTrack.muted = isPaused;
        }
        if (pauseMenu) {
          pauseMenu.classList.toggle("is-visible", isPaused);
          pauseMenu.setAttribute("aria-hidden", String(!isPaused));
        }
        resetKeys();
        if (isPaused) {
          if (document.exitPointerLock) {
            document.exitPointerLock();
          }
        } else if (!isTouch) {
          requestLock();
        }
      };

      const togglePause = () => {
        setPaused(!isPaused);
      };

      window.addEventListener("keydown", (event) => {
        if (isDialogOpen) {
          if (
            event.key === "Enter" ||
            event.key === " " ||
            event.code === "Space"
          ) {
            event.preventDefault();
            advanceDialog();
          }
          return;
        }
        if (event.key === "Escape") {
          event.preventDefault();
          if (performance.now() < ignoreEscapeUntil) {
            return;
          }
          togglePause();
          return;
        }
        if (isPaused) return;
        const key = event.key;
        if (
          key === "w" ||
          key === "W" ||
          event.code === "KeyW" ||
          key === "ArrowUp"
        ) {
          keys.forward = true;
        }
        if (
          key === "s" ||
          key === "S" ||
          event.code === "KeyS" ||
          key === "ArrowDown"
        ) {
          keys.backward = true;
        }
        if (
          key === "a" ||
          key === "A" ||
          event.code === "KeyA" ||
          key === "ArrowLeft"
        ) {
          keys.left = true;
        }
        if (
          key === "d" ||
          key === "D" ||
          event.code === "KeyD" ||
          key === "ArrowRight"
        ) {
          keys.right = true;
        }
      });

      window.addEventListener("keyup", (event) => {
        if (isDialogOpen) return;
        if (isPaused) return;
        const key = event.key;
        if (
          key === "w" ||
          key === "W" ||
          event.code === "KeyW" ||
          key === "ArrowUp"
        ) {
          keys.forward = false;
        }
        if (
          key === "s" ||
          key === "S" ||
          event.code === "KeyS" ||
          key === "ArrowDown"
        ) {
          keys.backward = false;
        }
        if (
          key === "a" ||
          key === "A" ||
          event.code === "KeyA" ||
          key === "ArrowLeft"
        ) {
          keys.left = false;
        }
        if (
          key === "d" ||
          key === "D" ||
          event.code === "KeyD" ||
          key === "ArrowRight"
        ) {
          keys.right = false;
        }
      });

      if (dialog) {
        dialog.addEventListener("click", (event) => {
          if (event.target.closest(".dialog-choice")) return;
          advanceDialog();
        });
      }

      const canvas = renderer.domElement;
      const requestLock = () => {
        if (canvas.requestPointerLock) {
          canvas.requestPointerLock();
        }
      };

      document.addEventListener("pointerlockchange", () => {
        pointerLocked = document.pointerLockElement === canvas;
        if (pointerLocked) {
          skipMouseMoves = 2;
          hadPointerLock = true;
        }
        if (!pointerLocked) {
          dragLook = false;
          dragPointerId = null;
          if (
            hadPointerLock &&
            gameStarted &&
            !isPaused &&
            !isTouch &&
            !isDialogOpen
          ) {
            const now = performance.now();
            if (now - lastPauseToggle > 200) {
              ignoreEscapeUntil = now + 250;
              setPaused(true);
            }
          }
        }
        if (!gameStarted && overlay) {
          overlay.classList.toggle("is-hidden", pointerLocked || isTouch);
        }
      });

      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("pointermove", onPointerMove);
      canvas.addEventListener("pointerdown", (event) => {
        if (isTouch) return;
        if (isPaused || isDialogOpen) return;
        if (!pointerLocked) {
          requestLock();
        }
        if (!pointerLocked) {
          dragLook = true;
          dragPointerId = event.pointerId;
          lastLookX = event.clientX;
          lastLookY = event.clientY;
          canvas.setPointerCapture?.(event.pointerId);
        }
      });
      const stopDragLook = (event) => {
        if (!dragLook) return;
        if (dragPointerId !== null && event.pointerId !== dragPointerId) {
          return;
        }
        dragLook = false;
        dragPointerId = null;
        if (canvas.hasPointerCapture?.(event.pointerId)) {
          canvas.releasePointerCapture?.(event.pointerId);
        }
      };
      window.addEventListener("pointerup", stopDragLook);
      window.addEventListener("pointercancel", stopDragLook);
      window.addEventListener("blur", () => {
        dragLook = false;
        dragPointerId = null;
      });

      if (isTouch) {
        canvas.addEventListener("touchstart", onPointerMoveTouch, {
          passive: true,
        });
        canvas.addEventListener("touchmove", onPointerMoveTouch, {
          passive: true,
        });
        canvas.addEventListener("touchend", resetTouchLook, { passive: true });
      }

      startBtn.addEventListener("click", () => {
        gameStarted = true;
        setPaused(false);
        if (!isTouch) {
          requestLock();
        }
        startMusic();
        if (overlay) {
          overlay.classList.add("is-hidden");
        }
      });

      if (resumeBtn) {
        resumeBtn.addEventListener("click", () => {
          setPaused(false);
        });
      }

      if (touchControls) {
        touchControls.querySelectorAll("[data-move]").forEach((btn) => {
          const action = btn.dataset.move;
          const activate = (value) => {
            if (action === "reset") {
              if (value) resetPlayer();
              return;
            }
            touchKeys[action] = value;
          };
          btn.addEventListener("touchstart", () => activate(true), {
            passive: true,
          });
          btn.addEventListener("touchend", () => activate(false), {
            passive: true,
          });
          btn.addEventListener("touchcancel", () => activate(false), {
            passive: true,
          });
          btn.addEventListener("mousedown", () => activate(true));
          btn.addEventListener("mouseup", () => activate(false));
          btn.addEventListener("mouseleave", () => activate(false));
        });
      }

      window.addEventListener("click", () => {
        if (
          !pointerLocked &&
          !isTouch &&
          !isPaused &&
          !isDialogOpen &&
          gameStarted
        ) {
          requestLock();
        }
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const clock = new THREE.Clock();
      const tempVec3 = new THREE.Vector3();
      const animate = () => {
        const delta = Math.min(clock.getDelta(), 0.05);
        const maxLookStep = 10 * delta;
        yaw += clamp(targetYaw - yaw, -maxLookStep, maxLookStep);
        pitch += clamp(targetPitch - pitch, -maxLookStep, maxLookStep);
        yawObject.rotation.y = yaw;
        pitchObject.rotation.x = pitch;
        updateMovement(delta);
        const currentCell = worldToCell(
          yawObject.position.x,
          yawObject.position.z
        );
        const inTopExitRoom =
          currentCell.x >= roomStartX &&
          currentCell.x <= roomEndX &&
          currentCell.y >= topRoomStartY &&
          currentCell.y <= topRoomEndY - 1;
        const inBottomExitRoom =
          currentCell.x >= roomStartX &&
          currentCell.x <= roomEndX &&
          currentCell.y >= bottomRoomStartY + 1 &&
          currentCell.y <= bottomRoomEndY;
        if (gameStarted && !isPaused && !isDialogOpen) {
          const exitKey = inTopExitRoom
            ? "top"
            : inBottomExitRoom
              ? "bottom"
              : "";
          if (exitKey) {
            if (!exitOrder.firstExit) {
              exitOrder.firstExit = exitKey;
              exitOrder.secondExit = exitKey === "top" ? "bottom" : "top";
              openDialogSequence(buildExitOneSequence(), () => {
                exitOrder.firstDone = true;
                exitDone[exitOrder.firstExit] = true;
                switchExitTrack(exitTrackSecondary);
              });
            } else if (
              exitKey === exitOrder.secondExit &&
              !exitOrder.secondDone
            ) {
              openDialogSequence(buildExitTwoSequence(), () => {
                exitOrder.secondDone = true;
                exitDone[exitOrder.secondExit] = true;
                if (centerTotem) {
                  centerTotem.visible = true;
                }
              });
            }
          }
        }
        if (audioStarted) {
          const now = performance.now();
          if (now - lastExitCheck > 600) {
            ensureExitTrackPlaying();
            lastExitCheck = now;
          }
          const distA = Math.hypot(
            yawObject.position.x - exitWorldA.x,
            yawObject.position.z - exitWorldA.z
          );
          const distB = Math.hypot(
            yawObject.position.x - exitWorldB.x,
            yawObject.position.z - exitWorldB.z
          );
          const topActive = !exitDone.top;
          const bottomActive = !exitDone.bottom;
          let nearest = Infinity;
          if (topActive) nearest = Math.min(nearest, distA);
          if (bottomActive) nearest = Math.min(nearest, distB);
          const inExitRoom =
            (inTopExitRoom && topActive) || (inBottomExitRoom && bottomActive);
          let exitFade = 0;
          if (Number.isFinite(nearest)) {
            exitFade = clamp(1 - nearest / exitFadeDistance, 0, 1);
          }
          if (inExitRoom) {
            exitFade = 1;
          }
          setMusicVolume(baseMusicVolume * (1 - exitFade));
          setExitVolume(baseExitVolume * exitFade);
        }
        starField.position.set(
          yawObject.position.x,
          yawObject.position.y + starYOffset,
          yawObject.position.z
        );
        glyphGroup.position.set(
          yawObject.position.x,
          yawObject.position.y + starYOffset,
          yawObject.position.z
        );
        const bands = getAudioBands(delta);
        const boostedLevel = clamp(
          Math.max(bands.high * 2.2, bands.overall * 1.6),
          0,
          1
        );
        starIntensity = starIntensity * 0.6 + boostedLevel * 0.4;
        starMaterials.forEach(({ material, baseSize }) => {
          material.size = baseSize + starIntensity * starSizeRange;
          material.opacity = clamp(0.35 + starIntensity * 1.1, 0.25, 1);
        });

        if (wallTextPanels.length) {
          const textPulse = clamp(
            starIntensity * 1.1 + bands.high * 0.6 + bands.beat * 0.5,
            0,
            1
          );
          wallTextPanels.forEach((panel) => {
            const scale = panel.baseScale * (1 + textPulse * 0.35);
            panel.mesh.scale.set(scale, scale, 1);
            panel.mesh.material.opacity = clamp(
              panel.baseOpacity + textPulse * 0.45,
              0.25,
              1
            );
          });
        }

        if (centerTotem?.visible) {
          const totemData = centerTotem.userData || {};
          const totemDistance = Math.hypot(
            yawObject.position.x - centerTotem.position.x,
            yawObject.position.z - centerTotem.position.z
          );
          const fadeRange = Math.max(
            0.001,
            centerTotemFadeStart - centerTotemFadeEnd
          );
          const proximityFade = clamp(
            (totemDistance - centerTotemFadeEnd) / fadeRange,
            0,
            1
          );
          if (totemData.decal) {
            camera.getWorldPosition(tempVec3);
            totemData.decal.lookAt(tempVec3);
            if (totemData.decal.material) {
              const baseOpacity =
                totemData.decalBaseOpacity ?? totemData.decal.material.opacity;
              totemData.decal.material.opacity = clamp(baseOpacity, 0, 1);
            }
          }
          if (totemData.totemMesh?.material) {
            const baseOpacity =
              totemData.totemBaseOpacity ?? totemData.totemMesh.material.opacity;
            totemData.totemMesh.material.opacity = clamp(baseOpacity, 0, 1);
          }
          const time = performance.now() * 0.001;
          const flicker = 0.85 + Math.sin(time * 3.1) * 0.15;
          const pulse = clamp(
            0.35 + starIntensity * 1.5 + bands.high * 0.9 + bands.beat * 1.1,
            0,
            1.6
          );
          const rawIntensity = clamp(pulse * flicker, 0, 1.6);
          const beamScale = (1 + rawIntensity * 0.35) * proximityFade;
          if (totemData.beamMesh?.material) {
            totemData.beamMesh.material.opacity = clamp(
              totemData.beamBaseOpacity *
                (0.6 + rawIntensity * 1.3) *
                proximityFade,
              0,
              1
            );
            totemData.beamMesh.scale.set(beamScale, 1, beamScale);
          }
          if (totemData.beamCore?.material) {
            const coreScale = (1 + rawIntensity * 0.22) * proximityFade;
            totemData.beamCore.material.opacity = clamp(
              totemData.coreBaseOpacity *
                (0.7 + rawIntensity * 1.5) *
                proximityFade,
              0,
              1
            );
            totemData.beamCore.scale.set(coreScale, 1, coreScale);
          }
          if (totemData.beamGlow?.material) {
            totemData.beamGlow.material.opacity = clamp(
              totemData.glowBaseOpacity *
                (0.75 + rawIntensity * 1.7) *
                proximityFade,
              0,
              1
            );
            const glowScale =
              totemData.glowBaseScale * (1 + rawIntensity * 1.9) * proximityFade;
            totemData.beamGlow.scale.set(glowScale, glowScale, 1);
          }
          if (totemData.particles?.geometry?.attributes?.position) {
            const positions = totemData.particles.geometry.attributes.position;
            const array = positions.array;
            const speeds = totemData.particleSpeeds || [];
            const beamTop = totemData.totemHeight + totemData.beamHeight;
            const speedBoost = 1 + rawIntensity * 2.1;
            for (let i = 0; i < speeds.length; i += 1) {
              const idx = i * 3;
              array[idx + 1] += speeds[i] * delta * speedBoost;
              if (array[idx + 1] > beamTop) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.1 + Math.random() * totemData.particleRadius;
                array[idx] = Math.cos(angle) * radius;
                array[idx + 2] = Math.sin(angle) * radius;
                array[idx + 1] =
                  totemData.totemHeight + Math.random() * 1.5;
              }
            }
            positions.needsUpdate = true;
            const particleMaterial = totemData.particles.material;
            if (particleMaterial) {
              const baseSize =
                totemData.particleBaseSize || particleMaterial.size;
              const baseOpacity =
                totemData.particleBaseOpacity || particleMaterial.opacity;
              particleMaterial.size =
                baseSize * (1 + rawIntensity * 1.4) * proximityFade;
              particleMaterial.opacity = clamp(
                baseOpacity * (0.7 + rawIntensity * 1.4) * proximityFade,
                0,
                1
              );
            }
          }
        }

        glyphs.forEach((glyph) => {
          const { sprite, band, baseScale } = glyph;
          let bandLevel = 0;
          if (band === "low") bandLevel = bands.low;
          if (band === "mid") bandLevel = bands.mid;
          if (band === "high") bandLevel = bands.high;
          if (band === "beat") bandLevel = bands.beat;
          const reactive = clamp(bandLevel * 2.1 + bands.overall * 0.35, 0, 1);
          glyph.bob += delta * 0.7;
          sprite.position.x += glyph.driftX * delta;
          sprite.position.y +=
            Math.sin(glyph.bob) * delta * 0.2 + glyph.driftY * delta * 0.35;
          sprite.position.z += glyph.driftZ * delta * 2.2;
          const glyphRadius = sprite.position.length();
          if (
            sprite.position.y < 0 ||
            sprite.position.y > starRadius * 1.9 ||
            glyphRadius > starRadius * 2.1
          ) {
            spawnGlyphPosition(glyph);
          }
          const scaleBoost = 0.55 + reactive * 1.8;
          sprite.scale.set(baseScale * 2.4 * scaleBoost, baseScale * 1.4 * scaleBoost, 1);
          sprite.material.opacity = clamp(0.25 + reactive * 1.15, 0.18, 1);
        });
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      };
      animate();
    </script>
  </body>
</html>
